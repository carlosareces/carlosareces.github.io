<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                              "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="em">  
      <head>
            <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
            <link rel="stylesheet" href="css/v4.css" type="text/css" media="screen" />
            <link rel="stylesheet" href="css/screen.css" type="text/css" media="screen" />
            <link rel="stylesheet" href="css/print.css" type="text/css" media="print" />

            <title>Primera Jornada de Doctorandos de Computacion</title>
      </head>

      <body>
      <div id="pageWrapper">
      
      <hr class="hide" />
      
      <div id="masthead" class="inside">
            <h1>Primera Jornada de Doctorandos de Computaci&oacute;n <br/> FaMAF, Universidad Nacional de C&oacute;rdoba</h1>
            <h2>6 de Diciembre, 2010</h2>
      </div>

      <hr class="hide" />

      <div class="hnav"> 
      
     
      </div> <!-- End HNAV -->
      
      <div id="outerColumnContainer">
            <div id="innerColumnContainer">
            
                  <hr class="hide" />

                  <div id="leftColumn">
                        <div class="inside">
<div class="vnav">
	<h3></h3>
	<ul>
        <li><a href="index.html#introduccion">Introducci&oacute;n</a></li>
        <li><a href="index.html#participantes">Participantes</a></li>
        <li><a href="index.html#programa">Programa</a></li>
    </ul>
		
        
</div> <!-- End VNAV -->

<br/>

</div> <!-- End INSIDE -->
                        
</div>

<hr class="hide" />

<div id="rightColumn">
<div class="inside">

</div>
</div>
<div id="contentColumn">
	<hr class="hide" />
	<a name="skipToContent"></a>
	<div class="inside">
	
<a name="introduccion"></a>
<h3>Introducci&oacute;n</h3>

<p>
Esta es la primera Jornada de Doctorandos de Computaci&oacute;n de la
Facultad de Matem&aacute;tica, Astronom&iacute;a y F&iacute;sica (FaMAF).
</p>

<p>
En esta jornada, los estudiantes del Doctorado en Ciencias de la
Computaci&oacute;n de FaMAF expondr&aacute;n sus intereses de investigaci&oacute;n y los
aspectos m&aacute;s relevantes de su trabajo. 
</p>

<p>
Uno de los principales
objetivos de la jornada es dar a conocer las l&iacute;neas de investigaci&oacute;n
que los doctorandos de Computaci&oacute;n del FaMAF est&aacute;n desarrollando,
y por eso invitamos a todos los alumnos y docentes (no s&oacute;lo a los
de Computaci&oacute;n) a concurrir.
</p>

<a name="participantes"></a>
<h3>Participantes Confirmados <a href="index.html#introduccion">^</a></h3>

Ac&aacute; ponemos la lista de todos los doctorandos que participan de las jornadas, en orden alfab&eacute;tico y con e-mail. As&iacute; el que est&eacute; interesado los puede buscar y/o/implica/forall contactar.  

<ul>

    <li> Araceli Acosta                         [<i>acostaaraceli AT gmail.com</i>] <br/>
    <b>Herramientas y mecanismos formales para el tratamiento de la tolerancia a fallas: S&iacute;ntesis de controladores</b>
    
    <p>
    Contar&eacute; un poco de qu&eacute; se trata mi tema de doctorado, y una peque&ntilde;a introducci&oacute;n a la t&eacute;cnica formal con la que estoy trabajando en este momento, "S&iacute;ntesis de controladores", y su aplicaci&oacute;n a la tolerancia a fallas. 
    </p>
    </li>


    <li> Romina Altamirano                      [<i>romina.altamirano AT gmail.com</i>]<br/> 
    <b>Mejorando la traducci&oacute;n autom&aacute;tica a trav&eacute;s de la incorporaci&oacute;n de 
conocimiento ling&uuml;&iacute;stico, simplificaci&oacute;n textual, y combinaci&oacute;n de motores de traducci&oacute;n</b>

<p>
 La traducci&oacute;n autom&aacute;tica es una tarea compleja porque requiere
 an&aacute;lisis de texto de origen, resolver ambig&uuml;edades de diversos tipos y
 generaci&oacute;n de texto en el idioma destino. Actualmente no existe un traductor de
 prop&oacute;sito general que exitosamente haga su tarea en todos los idiomas y dominios,
 Mejorar alg&uacute;n aspecto de la traducci&oacute;n autom&aacute;tica reducir&iacute;a notablemente el
 trabajo de post-edici&oacute;n, entre esas mejoras que se pueden realizar estan la
 de agregar conocimiento ling&uuml;&iacute;stico, simplificar el texto en una etapa de
 pre-edici&oacute;n, y combinar motores de traducci&oacute;n para explotar mejor las
 ventajas de cada uno de ellos.
 </p>
    </li>

   <li> Valeria Bengolea                       [<i>vbengolea AT dc.exa.unrc.edu.ar</i>]<br/>
   <b>Mejoras en la Generaci&oacute;n de casos de Test en Korat usando Criterios de Test</b>

<p>
La generaci&oacute;n autom&aacute;tica de casos de test es una &aacute;rea de investigaci&oacute;n muy
activa en la actualidad, dentro de la cual la generaci&oacute;n de casos de test
para estructuras complejas alojadas en memoria din&aacute;mica, tales como &aacute;rboles
balanceados, grafos, etc., es particularmente dif&iacute;cil. Korat es una herramienta/algoritmo 
que resuelve este problema de manera bastante efectiva, mediante la exploraci&oacute;n exhaustiva 
de potenciales casos de test. El mecanismo de constraint solving de Korat est&aacute; basado en 
b&uacute;squeda (backtracking), y depende fuertemente de una poderosa t&eacute;cnica de poda.

En esta charla presentar&eacute; una t&eacute;cnica para mejorar la generaci&oacute;n de
casos de test de la manera realizada por Korat, guiando la b&uacute;squeda a
trav&eacute;s de la consideraci&oacute;n de un criterio de test. Tal criterio se
emplea para poder podar la b&uacute;squeda a&uacute;n m&aacute;s, pero de una manera
similar a la utilizada por Korat.

Presentar&eacute; la t&eacute;cnica junto con algunos resultados experimentales que
muestran la performance de la t&eacute;cnica desarrollada para algunos
criterios de test, y una comparaci&oacute;n con Korat est&aacute;ndar.
</p>
   
   </li>


    <li> Hern&aacute;n Casal&aacute;nguida      [<i>9dearea AT gmail.com</i>]<br/>
<b>Desarrollo de Familias de Aplicaciones Web con Transformaci&oacute;n de Modelos</b>

<p>
El problema general a estudiar es el de definir una metodolog&iacute;a  apropiada para 
el desarrollo de familias de aplicaciones web (FAW)  intensivas en datos e incluyendo aplicaciones 
de internet ricas. 
Actualmente existe una presi&oacute;n muy grande para disminuir los costos y los tiempos de desarrollo 
de aplicaciones web; al mismo tiempo los diversos atributos de calidad de este tipo de 
software se ven afectados por el estilo de desarrollo desde cero. La disponibilidad de 
m&eacute;todos, conceptos de modelado, abstracciones b&aacute;sicas y por supuesto frameworks de desarrollo 
permitir&iacute;a contribuir de manera muy importante a esta problem&aacute;tica.
La  ingenier&iacute;a de FAW permitir&aacute; a las empresas mayores utilidades, mayor calidad en los 
productos y tiempos m&aacute;s cortos de desarrollo al poder construir las aplicaciones web de una FAW 
apoy&aacute;ndose en una  infraestructura reutilizable.
A pesar que la ingenier&iacute;a de familias de aplicaciones (IFA) es un &aacute;rea que empez&oacute; al comienzo 
de los 80, casi no se ha estudiado la ingenier&iacute;a de FAW y la investigaci&oacute;n permitir&aacute; 
mejorar y  comprender mejor esta nueva rama de la IFA. 
</p>   
</li>    

    <li> Julio Castillo                         [<i>jotacastillo AT gmail.com</i>] <br/>
    <b>Reconocimiento de Implicaci&oacute;n Textual empleando Aprendizaje Autom&aacute;tico </b>
    
    <p>
    Dados dos fragmentos de textos llamados T(Texto) e H(Hip&oacute;tesis), la tarea de reconocimiento de implicaci&oacute;n textual consiste en determinar si el significado de H puede ser inferido tomando T como valido o en el contexto de T.
De esta manera, la noci&oacute;n de "implicaci&oacute;n" se define como una relaci&oacute;n unidireccional que se sostiene entre dos expresiones del lenguaje, mientras que la relaci&oacute;n opuesta podr&iacute;a no mantenerse.
Como resultado podr&iacute;amos tener que esta relaci&oacute;n se sostiene, que la hip&oacute;tesis H  contradice el texto T, o bien que no hay suficiente informaci&oacute;n o se desconoce tal relaci&oacute;n.
As&iacute;, en esta charla se dar&aacute; una introducci&oacute;n al problema del Reconocimiento de Implicaci&oacute;n Textual, y a una aproximaci&oacute;n utilizando aprendizaje autom&aacute;tico para su resoluci&oacute;n. Se hablar&aacute; sobre la evoluci&oacute;n de dicha tarea desde su definici&oacute;n inicial y se comentar&aacute;n algunos resultados obtenidos hasta el momento.
    </p>
    </li>

    <li> Renato Cherini                         [<i>cherini AT gmail.com</i>]<br/>
    <b>Verificaci&oacute;n de sistemas de c&oacute;digo que utilizan memoria din&aacute;mica</b>
    <p>
    La Separation Logic es el est&aacute;ndar de facto en la verificaci&oacute;n formal de programas que utilizan memoria din&aacute;mica para implementar estructuras de datos mutables. Se introducir&aacute; brevemente esta l&oacute;gica y se discutir&aacute; sobre dos limitaciones que se encuentran al utilizarla en la verificaci&oacute;n de sistemas de c&oacute;digo: por un lado, en cuanto a la expresividad, la imposibilidad de especificar estructuras de datos que comparten la memoria para su representaci&oacute;n de forma compatible con el principio de "information hiding" caracter&iacute;stico de los actuales paradigmas de programaci&oacute;n imperativa; por otro lado, en un aspecto mas pr&aacute;ctico, la complejidad de las demostraciones necesarias y la dificultad de llevarlas adelante de forma manual. Se presentar&aacute;n dos trabajos que apuntan a resolver estas dificultades.</p>
    </li>


    <li> Renzo Degiovanni                        [<i>rdegiovanni8 AT gmail.com</i>] <br/>


<b>An&aacute;lisis Autom&aacute;tico basado en SAT aplicado a la Validaci&oacute;n de Requisitos de Software</b>

<p>Existe una amplia variedad de notaciones para la descripci&oacute;n de requisitos de software, pero aquellas con una sem&aacute;ntica formal son particularmente apropiadas para el an&aacute;lisis. En particular, la notaci&oacute;n tabular de Parnas y el m&eacute;todo Software Cost Reduction (SCR) resultan convenientes para la descripci&oacute;n formal de requisitos, pues basan sus notaciones en formas adecuadas de organizar expresiones relacionales, de manera tal que su comprensi&oacute;n y manipulaci&oacute;n sea m&aacute;s efectiva.

En esta charla discutiremos algunas ideas de c&oacute;mo atacar el problema de utilizar an&aacute;lisis basado en SAT para tareas ligadas a la validaci&oacute;n de requisitos de software especificados en las notaciones tabulares mencionadas, y aprovechando caracter&iacute;sticas propias de estas notaciones.

Entre los objetivos de an&aacute;lisis se encuentran el conseguir documentos de requisitos completos y consistentes.

Veremos que el an&aacute;lisis basado en SAT requiere, al igual que otras t&eacute;cnicas de an&aacute;lisis autom&aacute;tico, de mecanismos que contribuyan a su escalabilidad. Discutiremos uno particular, basado en abstracci&oacute;n, que resulta &uacute;til en el contexto de especificaciones tabulares.
</p>
</li>



    <li> Martin Dominguez                       [<i>mardom75 AT gmail.com</i>] <br/>
    <b>An&aacute;lisis de Dependencias no supervisado de dependencias basado en Gram&aacute;ticas Bil&eacute;xicas</b>

<p>El an&aacute;lisis de dependencias no supervisado, cuyo objetivo es adquirir conocimiento de un lenguaje a partir de un corpus sin ninguna anotaci&oacute;n, ha tomado gran importancia en el &aacute;rea del procesamiento natural en los &uacute;ltimos a&ntilde;os. Es utilizado como parte de sistemas de traducci&oacute;n autom&aacute;tica, sistemas de di&aacute;logos, buscadores y respuesta a preguntas (question answering), entre otros. El an&aacute;lisis de dependencias tiene como foco construir un modelo que permita inferir el &aacute;rbol de dependencias para una oraci&oacute;n dada.

En esta charla introducimos un analizador de dependencias no supervisado basado en gram&aacute;ticas bil&eacute;xicas. El modelo est&aacute; basado en la inferencia de una gram&aacute;tica bilexica, la cual se construye a partir de un conjunto de aut&oacute;matas que modelan el lenguaje de dependencias para cada categor&iacute;a sint&aacute;ctica (verbos, sustantivos, etc). Los resultados obtenidos por nuestro analizador son comparables con el estado del arte para el idioma ingl&eacute;s en oraciones de hasta diez palabras. La arquitectura definida, al estar basada en aut&oacute;matas, permite mucha flexibilidad; permitiendo definir distintas estructuras, dependiendo de los idiomas y de las categoras sint&aacute;cticas. Debido a esto, esperamos en trabajos futuros obtener buenos resultados tanto para oraciones de mayor longitud, como para otros idiomas como el alem&aacute;n, el turco y el espa&ntilde;ol.
</p>
    </li>

    <li> Ra&uacute;l Fervari           [<i>rfervari AT gmail.com</i>] <br/> 
    <b>L&oacute;gicas Modales: Cl&aacute;sicas y Din&aacute;micas</b> <br/>
    
    <p>En la charla se presentar&aacute; una introducci&oacute;n a algunos lenguajes l&oacute;gicos simples para mostrar la importancia 
de este tipo de lenguajes en nuestro trabajo (aplicaciones, preguntas a responder, resultados generales, etc.), y sus
limitaciones (expresividad, complejidad, etc.). Luego se proceder&aacute; a introducir de una manera
m&aacute;s formal el lenguaje modal b&aacute;sico, qu&eacute; nos permite decir acerca de estructuras relacionales, y se mostrar&aacute; por que no 
resulta suficiente para explorar todas las caracter&iacute;sticas de dichas estructuras, haciendo referencia a propiedades 
din&aacute;micas de los modelos. Para estudiar estas ideas, se presentar&aacute;n dos lenguajes creados con este fin: memory logic y
swap logic. El primer lenguaje se introducir&aacute; formal e informalmente a modo de ejemplo, mientras que el segundo, 
por ser espec&iacute;ficamente el tema en el que estamos trabajando en el momento, se presentar&aacute; mediante algunos resultados 
preliminares y discutiendo problemas a&uacute;n sin resolver.
    </p>
    </li>

    <li> Cecilia Kilmurray                      [<i>ckilmurray AT dc.exa.unrc.edu.ar</i>]<br/> 
<b>Utilizando L&oacute;gicas De&oacute;nticas y Temporales para la Especificaci&oacute;n de Sistemas Tolerantes a Fallas</b>

<p>
En la actualidad la tolerancia a fallas cada vez adquiere mas importancia, esto se debe a que cada d&iacute;a hay mas sistemas cr&iacute;ticos en donde es necesario garantizar cierto comportamiento deseado a&uacute;n ante la ocurrencia ocasional de fallas. Ejemplos de estos sistemas son: centrales nucleares, aviones, dispositivos m&eacute;dicos y cualquier otro sistema que se caracterice por un funcionamiento continuo, durante largo plazos de tiempo, y sin posibilidad de intervenci&oacute;n.

El inter&eacute;s en este tipo de sistemas, con altos niveles de disponibilidad y confiabilidad, ha llevado a un gran desarrollo a esta &aacute;rea de la computaci&oacute;n.

Sin embargo una caracter&iacute;stica sorprendente de la tolerancia a fallas es la falta de soluciones de prop&oacute;sito general, o ambientes para el an&aacute;lisis de sistemas tolerantes a fallas. La amplia mayor&iacute;a de las soluciones a problemas de tolerancia a fallas son ad hoc, y atacan problemas particulares en contextos espec&iacute;ficos. En el caso de t&eacute;cnicas para tolerancia a fallas en software, las soluciones m&aacute;s importantes tienen que ver con redundancia o diversidad.

En esta charla presentar&eacute; brevemente las caracter&iacute;sticas b&aacute;sicas de algunos frameworks l&oacute;gicos que pensamos utilizar para razonar sobre tolerancia a fallas. En particular mostrar&eacute; algunos ejemplos para ilustrar la capacidad de ciertas l&oacute;gicas de&oacute;nticas para capturar nociones relacionadas con tolerancia a fallas.

Culminar&eacute; presentando algunas de las ideas de lo que respecta a an&aacute;lisis probabil&iacute;stico de propiedades de sistemas, como esto se relaciona con lo  antes explicado y el plan de trabajo a futuro.
</p>
</li>


    <li> Matias Lee [<i>lee.matias AT gmail.com</i>]<br/>
        <b>A Refinement Based Notion of Non-Interference for Interface Automata: Compositionality, Decidability and Synthesis</b>

<p>
Interface automata (IA) introduce a framework to model stateful interfaces.  Interface structures for security (ISS) extend IA to cope with security properties. 
In this work, we argue that bisimulation-based non interference is not quite appropriate to characterize security on ISSs.
We instead introduce a refinement-based variant of non-interference that fits better in this context.
Moreover, we show that these new properties are not preserved by composition, but give sufficient conditions to ensure compositionality.
We give two algorithms. The first one determines if an ISS satisfies the refinement-based non-interference property. The second one, determines if an ISS can be made secure by controlling some input actions, and if so, synthesizes the secure ISS.
</p>
        </li>



    <li> Franco Luque                           [<i>francolq AT gmail.com</i>]<br/> 
    <b>Inducci&oacute;n No Supervisada de Gram&aacute;ticas de Lenguaje Natural</b>
    <p>Uno de los problemas centrales del &aacute;rea de Procesamiento de Lenguaje Natural es
el desarrollo de analizadores sint&aacute;cticos (parsers) de oraciones.
En el caso supervisado, los parsers "aprenden" la gram&aacute;tica de una lengua en una fase previa de entrenamiento, en la que se utiliza un corpus de texto previamente analizado sint&aacute;cticamente por ling&uuml;istas.
El caso no supervisado es una versi&oacute;n mucho m&aacute;s compleja del problema de an&aacute;lisis sint&aacute;ctico. En este caso, los parsers se entrenan solamente con oraciones sin analizar, es decir, con texto de lenguaje natural en bruto. El parsing no supervisado resulta interesante para su aplicaci&oacute;n en idiomas para los que no existen corpus sint&aacute;cticos, y tambi&eacute;n para modelar la adquisici&oacute;n del lenguaje por parte de los humanos, un problema central de estudio de las ciencias cognitivas.
Un &aacute;rea relacionada al parsing no supervisado de lenguaje natural es el de la Inferencia Gramatical de lenguajes formales. En este &aacute;mbito se estudia la posibilidad de aprender un lenguaje formal a partir de una secuencia de ejemplos del lenguaje. Existen definiciones formales para aprendibilidad de diferentes tipos, y resultados de aprendibilidad para diferentes clases de lenguajes dentro de la jerarqu&iacute;a de Chomsky.
En esta charla presentar&eacute; el problema de parsing no supervisado desde el punto de vista de la Inferencia Gramatical, relacionando el lenguaje natural con los lenguajes formales.
</p>
</li>

    <li> Ezequiel Orbe                          [<i>ezequiel.orbe AT gmail.com</i>] <br/> 
    <b>Machine-based Heuristics for propositional SAT solving</b>
    
    <p>This talk, consists of two parts. In the first one, I will present the main goals of our research, which aims at the development of new machine-learning based algorithms and heuristics, and the improvement of the existing ones, in particular, branching heuristics, in the context of complete sat solvers. 

In the second part, I will present a brief introduction to our current work, namely, exploiting symmetry in propositional sat-solving. 

The symmetry of a discrete object can be defined informally as a permutation of its components that leaves the object intact. In the context of sat-solving we can defined symmetry as a mapping of a sat problem onto itself that preserves its structure as well as its solutions. Many classes of reasoning problems, in particular, those arising from real world applications, displays a large amount of symmetry. In mathematical and common-sense reasoning, such symmetries are often used to reduce the difficulty of reasoning.

The use of symmetries in search problems is conceptually simple. If several points of the search space are related by a symmetry then we never want to visit more than one of them. In order to accomplish this we must solve two problems. First, the symmetries need to be discovered. Second, we need to make use of the symmetries. The talk will present a survey of the theoretical background and techniques that are available to attack this two problems.
    </p>
    </li>

    <li> Miguel Pagano                          [<i>miguel.pagano AT gmail.com</i>] <br/>
    <b>Normalizaci&oacute;n por evaluaci&oacute;n</b>
    <p>
    Un sistema de tipos tiene adem&aacute;s de las reglas de tipado
algunas reglas de computaci&oacute;n, que determinan una noci&oacute;n
de forma normal para los t&eacute;rminos. Una manera de obtener
esa forma normal es utilizando Normalizaci&oacute;n por Evaluaci&oacute;n;
en esta t&eacute;cnica se utiliza un modelo  sem&aacute;ntico para el cual
se puede definir una funci&oacute;n de reificaci&oacute;n que mapea ciertos
elementos del dominio sem&aacute;ntico a t&eacute;rminos en forma normal.
En esta charla presentaremos la t&eacute;cnica para el c&aacute;lculo lambda
simplemente tipado y luego comentaremos sobre trabajos
recientes en Normalizaci&oacute;n por Evaluaci&oacute;n para teor&iacute;as de
tipos dependientes.
    </p>
    </li>


    <li> Silvia Pelozo                          [<i>spelozo AT famaf.unc.edu.ar</i>] <br/>
    <b>Razonando sobre seguridad en sistemas distribuidos probabilistas por medio de alcanzabilidad acotada</b>

<p> 
La charla presenta avances del trabajo en curso para desarrollar un algoritmo que calcule propiedades cuantitativas de alcanzabilidad en sistemas distribuidos. Consideramos sistemas con comportamiento no determinista y probabilista, cuyos componentes deben basar sus decisiones s&oacute;lo en informaci&oacute;n local. Esto es importante por dos razones: primero porque los l&iacute;mites de los valores de probabilidad son m&aacute;s realistas, y segundo porque permite razonar sobre propiedades de seguridad.
Las t&eacute;cnicas tradicionales de model-checking probabilista resultan inadecuadas en estos sistemas, porque se basan en todas las posibles resoluciones del no determinismo introducido al intercalar procesos, considerando tambi&eacute;n opciones poco realistas, como por ejemplo que un proceso elija su siguiente acci&oacute;n de acuerdo a lo observado en otro proceso.
Para salvar esta limitaci&oacute;n recurrimos a restricciones sobre la resoluci&oacute;n del no determinismo, como las de los schedulers distribuidos, los fuertemente distribuidos, y en particular en esta charla proponemos restricciones adicionales que permiten razonar sobre propiedades de seguridad.
Por cuestiones de decidibilidad no es posible calcular propiedades de alcanzabilidad no acotada, pero discutimos un algoritmo para calcular alcanzabilidad acotada, consistente en la interpretaci&oacute;n de la resoluci&oacute;n del no determinismo como par&aacute;metros, con lo que se reduce el problema de model-checking a un problema de optimizaci&oacute;n no lineal.
</p>

    </li>

    <li> Eduardo Romero                         [<i>eromero AT conae.gov.ar</i>] <br/>
    <b>AI Planning and Scheduling: enfoques, formalismos y aplicaciones</b>
    <p>
    Los problemas de planificaci&oacute;n y scheduling aparecen en contextos de lo m&aacute;s
variados, y muchas veces veces est&aacute;n profundamente relacionados como un &uacute;nico 
problema. Sin embargo, tanto en la pr&aacute;ctica como en la teor&iacute;a, las t&eacute;cnicas 
utilizadas para resolverlos divergen profundamente en la forma de 
representaci&oacute;n, en su alcance y en los tipos de problemas que son capaces de 
abordar. En esta charla se presentar&aacute; de qu&eacute; se tratan este tipo de problemas 
y varios enfoques existentes para resolverlos. Pasando a las aplicaciones, voy 
a comentar c&oacute;mo aparecen estos problemas de manera natural en las operaciones 
de misiones espaciales.
    </p>
    </li>


    <li> Nicol&aacute;s Wolovick                [<i>nwolovick AT gmail.com</i>] <br/>
    <b>Measurability for Safety Verification of Stochastic Hybrid Systems</b>

    <p>
    Dealing with the interplay of randomness and continuous time is important for the formal verification of many real systems.
Considering both facets is especially important for wireless sensor networks, distributed control applications, and many other systems of growing importance.
An important traditional design and verification goal for such systems is to ensure that unsafe states can never be reached.
In the stochastic setting, this translates to the question whether the probability to reach unsafe states remains tolerable.

We consider stochastic hybrid systems where the continuous-time behavior is given by differential equations, as for usual hybrid systems.
The discrete jumps are given by either continuous probabilities, or discrete probability distributions with continuous nondeterminism.
The latter is exploited in an abstraction method that establishes safe upper bounds on reachability probabilities.
To arrive there requires us to express the model in a semantic setting that could handle both continuous probabilism and nondeterminism.

We will show that Nondeterministic Labeled Markov Process (NLMP) is an adequate model to capture this semantics.
These examples will bring evidence that the hit sigma algebra, one of the novel ingredients of NLMP, is adequate for doing the proofs.
We will also explore how to specify probabilistic nondeterminism using the generators Delta<sup>p</sup>(A) of the set of probabilities sigma algebra Delta(Sigma).
    </p>    
    </li>



    
</ul>

<h3>Programa del Evento <a href="index.html#introduccion">^</a></h3>
<a name="programa"></a>

<table style="margin-left: auto; margin-right: auto;" border="1" width="80%" cellpadding="3">
<tbody>
<tr>
<td width="90" align="center">09.00 - 09.10</td>
<td>Apertura</td>
</tr>
<tr>
<td width="90" align="center">09.10 - 09.30</td>
<td>Charla 01: <br/>
    <i>Raul Fervari</i><br/>
    <b>L&oacute;gicas Modales: Cl&aacute;sicas y Din&aacute;micas</b><br/>
    [<a href="Slides/fervari.pdf">slides</a>]
    </td>
</tr>
<tr>
<td width="90" align="center">09.30 - 09.50</td>
<td>Charla 02: <br/>
    <i>Romina Altamirano</i><br/>
     
    <b>Mejorando la traducci&oacute;n autom&aacute;tica a trav&eacute;s de la incorporaci&oacute;n de 
conocimiento ling&uuml;&iacute;stico, simplificaci&oacute;n textual, y combinaci&oacute;n de motores de traducci&oacute;n</b>
    </td>
</tr>
<tr>
<td width="90" align="center">09.50 - 10.10</td>
<td>Charla 03: <br/>
    <i>Araceli Acosta</i><br/>
    <b>Herramientas y mecanismos formales para el tratamiento de la tolerancia a fallas: S&iacute;ntesis de controladores</b>
     
</td>
</tr>
<tr>
<td width="90" align="center">10.10 - 10.30</td>
<td>Charla 04: <br/>
    <i>Miguel Pagano</i><br/>
    <b>Normalizaci&oacute;n por evaluaci&oacute;n</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">10.30 - 11.00</td>
<td>Coffee Break</td>
</tr>
<tr>
<td width="90" align="center">11.00 - 11.20</td>
<td>Charla 05: <br/>
    <i>Martin Dominguez</i><br/>
     <b>An&aacute;lisis no supervisado de dependencias basado en Gram&aacute;ticas Bil&eacute;xicas</b>
    </td>
</tr>
<tr>
<td width="90" align="center">11.20 - 11.40</td>
<td>Charla 06: <br/>
    <i>Hernan Casal&aacute;nguida</i><br/>
    <b>Desarrollo de Familias de Aplicaciones Web con Transformaci&oacute;n de Modelos</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">11.40 - 12.00</td>
<td>Charla 07: <br/>
    <i>Julio Castillo</i><br/>
    <b>Reconocimiento de Implicaci&oacute;n Textual empleando Aprendizaje Autom&aacute;tico </b> 
    </td>
</tr>
<tr>
<td width="90" align="center">12.00 - 12.20</td>
<td>Charla 08: <br/>
    <i>Eduardo Romero</i><br/>
    <b> AI Planning and Scheduling: enfoques, formalismos y aplicaciones </b>  
    </td>
</tr>
<tr>
<td width="90" align="center">12.20 - 14.00</td>
<td>Almuerzo</td>
</tr>
<tr>
<td width="90" align="center">14.00 - 14.20</td>
<td>Charla 09: <br/>
    <i>Franco Luque</i><br/>
    <b>Inducci&oacute;n No Supervisada de Gram&aacute;ticas de Lenguaje Natural</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">14.20 - 14.40</td>
<td>Charla 10: <br/>
    <i>Cecilia Kilmurray</i><br/>
    <b>Utilizando L&oacute;gicas De&oacute;nticas y Temporales para la Especificaci&oacute;n de Sistemas Tolerantes a Fallas</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">14.40 - 15.00</td>
<td>Charla 11: <br/>
    <i>Renzo Degiovanni</i><br/>
    <b>An&aacute;lisis Autom&aacute;tico basado en SAT aplicado a la Validaci&oacute;n de Requisitos de Software</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">15.00 - 15.20</td>
<td>Charla 12: <br/>
    <i>Valeria Bengolea</i><br/>
    <b>Mejoras en la Generaci&oacute;n de casos de Test en Korat usando Criterios de Test</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">15.20 - 16.30</td>
<td>Merienda</td>
</tr>
<tr>
<td width="90" align="center">16.30 - 16.50</td>
<td>Charla 13: <br/>
    <i>Nicol&aacute;s Wolovick</i><br/>
    <b>Measurability for Safety Verification of Stochastic Hybrid Systems</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">16.50 - 17.10</td>
<td>Charla 14: <br/>
    <i>Ezequiel Orbe</i><br/>
    <b>Machine-based Heuristics for propositional SAT solving</b> 
    </td>
</tr>
<tr>
<td width="90" align="center">17.10 - 17.30</td>
<td>Charla 15: <br/>
    <i>Matias Lee</i><br/>
     <b>A Refinement Based Notion of Non-Interference for Interface Automata: Compositionality, Decidability and Synthesis</b>
    </td>
</tr>

<tr>
<td width="90" align="center">17.30 - 17.50</td>
<td>Charla 16: <br/>
    <i>Silvia Pelozo</i><br/>
    <b>Razonando sobre seguridad en sistemas distribuidos probabilistas por medio de alcanzabilidad acotada</b> 
    </td>
</tr>

<tr>
<td width="90" align="center">17.50 - 18.10</td>
<td>Charla 17: <br/>
    <i>Renato Cherini</i><br/>
    <b>Verificaci&oacute;n de sistemas de c&oacute;digo que utilizan memoria din&aacute;mica</b> 
    </td>
</tr>

<tr>
<td width="90" align="center">18.10 - 18.30</td>
<td>Cierre</td>
</tr>
</tbody>
</table>

<br/>
<br/>

</div>
					</div>
					
          
<div class="clear mozclear"></div>
				</div>
			</div>
			<div class="hide" id="nsFooterClear"><!-- for NS4s sake --></div>
			<hr class="hide" />
			<div id="footer" class="inside">

<p style="margin:0;">
	<span style="color:#cc9;">
<a href="http://validator.w3.org/check/referer">
                 <img src="images/xhtml10.png" align="middle" alt="xhtml" width="80" height="15" style="border-width:0;"/>
             </a>
        &copy; 2010 Maintained by Areces. Last updated: 30-11-2010.
<a href="http://jigsaw.w3.org/css-validator/check/referer">
                <img src="images/css.png"  align="middle" alt="CSS" width="80" height="15" style="border-width:0;"/>
             </a>
        </span>
</p>

			</div>
			<hr class="hide" />
		</div>
	</body>
</html>
